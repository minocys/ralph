#!/bin/bash
# task â€” CLI for interacting with the Ralph task backlog via PostgreSQL
set -euo pipefail

# ---------------------------------------------------------------------------
# Database connection
# ---------------------------------------------------------------------------
db_check() {
    if [[ -z "${RALPH_DB_URL:-}" ]]; then
        echo "Error: RALPH_DB_URL environment variable is not set" >&2
        echo "Example: export RALPH_DB_URL='postgres://ralph:pass@localhost:5432/ralph'" >&2
        exit 1
    fi
}

psql_cmd() {
    psql "$RALPH_DB_URL" -tAX "$@"
}

# ---------------------------------------------------------------------------
# Schema management
# ---------------------------------------------------------------------------
ensure_schema() {
    psql_cmd -c "
    SET client_min_messages TO WARNING;
    CREATE TABLE IF NOT EXISTS tasks (
        id              TEXT PRIMARY KEY,
        title           TEXT NOT NULL,
        description     TEXT,
        category        TEXT,
        priority        INT DEFAULT 2,
        status          TEXT DEFAULT 'open',
        spec_ref        TEXT,
        ref             TEXT,
        result          JSONB,
        assignee        TEXT,
        lease_expires_at TIMESTAMPTZ,
        retry_count     INT DEFAULT 0,
        created_at      TIMESTAMPTZ DEFAULT now(),
        updated_at      TIMESTAMPTZ,
        deleted_at      TIMESTAMPTZ
    );

    CREATE TABLE IF NOT EXISTS task_steps (
        task_id TEXT REFERENCES tasks(id) ON DELETE CASCADE,
        seq     INT,
        content TEXT,
        status  TEXT DEFAULT 'pending',
        PRIMARY KEY (task_id, seq)
    );

    CREATE TABLE IF NOT EXISTS task_deps (
        task_id    TEXT REFERENCES tasks(id) ON DELETE CASCADE,
        blocked_by TEXT REFERENCES tasks(id) ON DELETE CASCADE,
        PRIMARY KEY (task_id, blocked_by)
    );

    CREATE TABLE IF NOT EXISTS agents (
        id         TEXT PRIMARY KEY,
        pid        INT,
        hostname   TEXT,
        started_at TIMESTAMPTZ DEFAULT now(),
        status     TEXT DEFAULT 'active'
    );
    " > /dev/null
}

# ---------------------------------------------------------------------------
# Usage / help
# ---------------------------------------------------------------------------
usage() {
    cat <<'EOF'
Usage: task <command> [options]

Plan Phase Commands:
  plan-sync             Read JSONL from stdin, upsert tasks into the database
  plan-export [--json]  Dump the full task DAG (table or JSONL)
  plan-status           Print summary: N open, N active, N done, N blocked, N deleted

Build Phase Commands:
  claim [--lease N]          Atomically claim highest-priority unblocked task
  renew <id> [--lease N]     Extend lease on an active task
  step-done <id> <seq>       Mark a step as done
  done <id> --result '<json>'  Mark task as done, store result
  fail <id> --reason "<text>"  Release task back to open

Shared Commands:
  list [--status S] [--json]   List tasks (default: non-deleted)
  show <id> [--with-deps]      Full detail for one task
  create <id> <title> [opts]   Create a task
  update <id> [opts]           Update fields on a non-done task
  delete <id>                  Soft delete a task
  deps <id>                    Show dependency tree

Dependency Commands:
  block <id> --by <blocker-id>    Add a dependency
  unblock <id> --by <blocker-id>  Remove a dependency

Agent Commands:
  agent register              Register a new agent
  agent list                  Show active agents
  agent deregister <id>       Mark agent as stopped

Environment:
  RALPH_DB_URL   PostgreSQL connection string (required)
EOF
}

# ---------------------------------------------------------------------------
# Subcommand stubs (will be implemented in subsequent tasks)
# ---------------------------------------------------------------------------
cmd_plan_sync()    { echo "plan-sync: not yet implemented" >&2; exit 1; }
cmd_plan_export()  { echo "plan-export: not yet implemented" >&2; exit 1; }
cmd_plan_status()  { echo "plan-status: not yet implemented" >&2; exit 1; }
cmd_claim()        { echo "claim: not yet implemented" >&2; exit 1; }
cmd_renew()        { echo "renew: not yet implemented" >&2; exit 1; }
cmd_step_done()    { echo "step-done: not yet implemented" >&2; exit 1; }
cmd_done()         { echo "done: not yet implemented" >&2; exit 1; }
cmd_fail()         { echo "fail: not yet implemented" >&2; exit 1; }
cmd_list() {
    local status_filter=""
    local json_output=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status) status_filter="$2"; shift 2 ;;
            --json)   json_output=1; shift ;;
            *) echo "Error: unknown flag '$1'" >&2; exit 1 ;;
        esac
    done

    # Build WHERE clause
    local where_clause
    if [[ -n "$status_filter" ]]; then
        # Convert comma-separated statuses to SQL IN clause
        local in_list=""
        IFS=',' read -ra statuses <<< "$status_filter"
        for s in "${statuses[@]}"; do
            s=$(printf '%s' "$s" | xargs)  # trim whitespace
            if [[ -n "$in_list" ]]; then
                in_list+=","
            fi
            in_list+="'${s}'"
        done
        where_clause="WHERE status IN (${in_list})"
    else
        where_clause="WHERE status != 'deleted'"
    fi

    if [[ "$json_output" -eq 1 ]]; then
        # JSONL output with short keys
        psql_cmd -c "
            SELECT json_build_object(
                'id', t.id,
                't', t.title,
                'd', t.description,
                'p', t.priority,
                's', t.status,
                'cat', t.category,
                'spec', t.spec_ref,
                'ref', t.ref,
                'deps', COALESCE((SELECT json_agg(td.blocked_by) FROM task_deps td WHERE td.task_id = t.id), '[]'::json),
                'steps', COALESCE((SELECT json_agg(json_build_object('seq', ts.seq, 'content', ts.content, 'status', ts.status) ORDER BY ts.seq) FROM task_steps ts WHERE ts.task_id = t.id), '[]'::json)
            )
            FROM tasks t
            ${where_clause}
            ORDER BY t.priority ASC, t.created_at ASC;
        "
    else
        # Table output: ID, P, S, CAT, TITLE, AGENT
        local result
        result=$(psql_cmd -c "
            SELECT t.id, t.priority, t.status, COALESCE(t.category, '-'), t.title, COALESCE(t.assignee, '-')
            FROM tasks t
            ${where_clause}
            ORDER BY t.priority ASC, t.created_at ASC;
        ")

        if [[ -z "$result" ]]; then
            return 0
        fi

        # Print header and rows with column alignment
        printf '%-20s %s %-8s %-5s %-35s %s\n' "ID" "P" "S" "CAT" "TITLE" "AGENT"
        while IFS='|' read -r id priority status category title assignee; do
            printf '%-20s %s %-8s %-5s %-35s %s\n' "$id" "$priority" "$status" "$category" "$title" "$assignee"
        done <<< "$result"
    fi
}
cmd_show()         { echo "show: not yet implemented" >&2; exit 1; }
cmd_create() {
    local id="${1:-}"
    shift 2>/dev/null || true
    local title="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$id" ]]; then
        echo "Error: missing task ID" >&2
        echo "Usage: task create <id> <title> [-p PRIORITY] [-c CATEGORY] [-d DESCRIPTION] [-s STEPS_JSON] [-r SPEC_REF] [--ref REF] [--deps DEP_IDS]" >&2
        exit 1
    fi

    if [[ -z "$title" ]]; then
        echo "Error: missing task title" >&2
        echo "Usage: task create <id> <title> [-p PRIORITY] [-c CATEGORY] [-d DESCRIPTION] [-s STEPS_JSON] [-r SPEC_REF] [--ref REF] [--deps DEP_IDS]" >&2
        exit 1
    fi

    local priority=2
    local category=""
    local description=""
    local steps_json=""
    local spec_ref=""
    local ref=""
    local deps=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p) priority="$2"; shift 2 ;;
            -c) category="$2"; shift 2 ;;
            -d) description="$2"; shift 2 ;;
            -s) steps_json="$2"; shift 2 ;;
            -r) spec_ref="$2"; shift 2 ;;
            --ref) ref="$2"; shift 2 ;;
            --deps) deps="$2"; shift 2 ;;
            *) echo "Error: unknown flag '$1'" >&2; exit 1 ;;
        esac
    done

    # sql_esc: double single quotes for SQL string literals
    sql_esc() { printf '%s' "$1" | sed "s/'/''/g"; }

    local esc_id esc_title esc_desc esc_category esc_spec_ref esc_ref
    esc_id=$(sql_esc "$id")
    esc_title=$(sql_esc "$title")
    esc_desc=$(sql_esc "$description")
    esc_category=$(sql_esc "$category")
    esc_spec_ref=$(sql_esc "$spec_ref")
    esc_ref=$(sql_esc "$ref")

    # Build INSERT for tasks
    local sql
    sql="BEGIN;
INSERT INTO tasks (id, title, description, category, priority, spec_ref, ref, updated_at)
VALUES ('${esc_id}', '${esc_title}'"
    if [[ -n "$description" ]]; then
        sql+=", '${esc_desc}'"
    else
        sql+=", NULL"
    fi
    if [[ -n "$category" ]]; then
        sql+=", '${esc_category}'"
    else
        sql+=", NULL"
    fi
    sql+=", ${priority}"
    if [[ -n "$spec_ref" ]]; then
        sql+=", '${esc_spec_ref}'"
    else
        sql+=", NULL"
    fi
    if [[ -n "$ref" ]]; then
        sql+=", '${esc_ref}'"
    else
        sql+=", NULL"
    fi
    sql+=", now());"

    # Insert steps from JSON array: [{"content":"step text"}, ...]
    if [[ -n "$steps_json" ]]; then
        local step_count
        step_count=$(printf '%s' "$steps_json" | jq 'length')
        for ((i=0; i<step_count; i++)); do
            local step_content esc_step
            step_content=$(printf '%s' "$steps_json" | jq -r ".[$i].content")
            esc_step=$(sql_esc "$step_content")
            sql+="
INSERT INTO task_steps (task_id, seq, content) VALUES ('${esc_id}', $((i+1)), '${esc_step}');"
        done
    fi

    # Insert dependencies
    if [[ -n "$deps" ]]; then
        IFS=',' read -ra dep_arr <<< "$deps"
        for dep in "${dep_arr[@]}"; do
            dep=$(printf '%s' "$dep" | xargs)  # trim whitespace
            local esc_dep
            esc_dep=$(sql_esc "$dep")
            sql+="
INSERT INTO task_deps (task_id, blocked_by) VALUES ('${esc_id}', '${esc_dep}');"
        done
    fi

    sql+="
COMMIT;"

    printf '%s\n' "$sql" | psql_cmd --set ON_ERROR_STOP=1 > /dev/null
    echo "$id"
}
cmd_update()       { echo "update: not yet implemented" >&2; exit 1; }
cmd_delete()       { echo "delete: not yet implemented" >&2; exit 1; }
cmd_deps()         { echo "deps: not yet implemented" >&2; exit 1; }
cmd_block()        { echo "block: not yet implemented" >&2; exit 1; }
cmd_unblock()      { echo "unblock: not yet implemented" >&2; exit 1; }

cmd_agent() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true
    case "$subcmd" in
        register)   echo "agent register: not yet implemented" >&2; exit 1 ;;
        list)       echo "agent list: not yet implemented" >&2; exit 1 ;;
        deregister) echo "agent deregister: not yet implemented" >&2; exit 1 ;;
        "")
            echo "Error: missing agent subcommand" >&2
            echo "Usage: task agent <register|list|deregister>" >&2
            exit 1
            ;;
        *)
            echo "Error: unknown agent subcommand '$subcmd'" >&2
            exit 1
            ;;
    esac
}

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------
main() {
    local cmd="${1:-}"
    shift 2>/dev/null || true

    case "$cmd" in
        --help|-h)
            usage
            exit 0
            ;;
        plan-sync)    db_check; ensure_schema; cmd_plan_sync "$@" ;;
        plan-export)  db_check; ensure_schema; cmd_plan_export "$@" ;;
        plan-status)  db_check; ensure_schema; cmd_plan_status "$@" ;;
        claim)        db_check; ensure_schema; cmd_claim "$@" ;;
        renew)        db_check; ensure_schema; cmd_renew "$@" ;;
        step-done)    db_check; ensure_schema; cmd_step_done "$@" ;;
        done)         db_check; ensure_schema; cmd_done "$@" ;;
        fail)         db_check; ensure_schema; cmd_fail "$@" ;;
        list)         db_check; ensure_schema; cmd_list "$@" ;;
        show)         db_check; ensure_schema; cmd_show "$@" ;;
        create)       db_check; ensure_schema; cmd_create "$@" ;;
        update)       db_check; ensure_schema; cmd_update "$@" ;;
        delete)       db_check; ensure_schema; cmd_delete "$@" ;;
        deps)         db_check; ensure_schema; cmd_deps "$@" ;;
        block)        db_check; ensure_schema; cmd_block "$@" ;;
        unblock)      db_check; ensure_schema; cmd_unblock "$@" ;;
        agent)        db_check; ensure_schema; cmd_agent "$@" ;;
        "")
            echo "Error: missing command" >&2
            echo "" >&2
            usage >&2
            exit 1
            ;;
        *)
            echo "Error: unknown command '$cmd'" >&2
            exit 1
            ;;
    esac
}

main "$@"
