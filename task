#!/bin/bash
# task â€” CLI for interacting with the Ralph task backlog via PostgreSQL
set -euo pipefail

# ---------------------------------------------------------------------------
# Database connection
# ---------------------------------------------------------------------------
db_check() {
    if [[ -z "${RALPH_DB_URL:-}" ]]; then
        echo "Error: RALPH_DB_URL environment variable is not set" >&2
        echo "Example: export RALPH_DB_URL='postgres://ralph:pass@localhost:5432/ralph'" >&2
        exit 1
    fi
}

psql_cmd() {
    psql "$RALPH_DB_URL" -tAX "$@"
}

# ---------------------------------------------------------------------------
# Schema management
# ---------------------------------------------------------------------------
ensure_schema() {
    psql_cmd -c "
    SET client_min_messages TO WARNING;
    CREATE TABLE IF NOT EXISTS tasks (
        id              TEXT PRIMARY KEY,
        title           TEXT NOT NULL,
        description     TEXT,
        category        TEXT,
        priority        INT DEFAULT 2,
        status          TEXT DEFAULT 'open',
        spec_ref        TEXT,
        ref             TEXT,
        result          JSONB,
        assignee        TEXT,
        lease_expires_at TIMESTAMPTZ,
        retry_count     INT DEFAULT 0,
        created_at      TIMESTAMPTZ DEFAULT now(),
        updated_at      TIMESTAMPTZ,
        deleted_at      TIMESTAMPTZ
    );

    CREATE TABLE IF NOT EXISTS task_steps (
        task_id TEXT REFERENCES tasks(id) ON DELETE CASCADE,
        seq     INT,
        content TEXT,
        status  TEXT DEFAULT 'pending',
        PRIMARY KEY (task_id, seq)
    );

    CREATE TABLE IF NOT EXISTS task_deps (
        task_id    TEXT REFERENCES tasks(id) ON DELETE CASCADE,
        blocked_by TEXT REFERENCES tasks(id) ON DELETE CASCADE,
        PRIMARY KEY (task_id, blocked_by)
    );

    CREATE TABLE IF NOT EXISTS agents (
        id         TEXT PRIMARY KEY,
        pid        INT,
        hostname   TEXT,
        started_at TIMESTAMPTZ DEFAULT now(),
        status     TEXT DEFAULT 'active'
    );
    " > /dev/null
}

# ---------------------------------------------------------------------------
# Usage / help
# ---------------------------------------------------------------------------
usage() {
    cat <<'EOF'
Usage: task <command> [options]

Plan Phase Commands:
  plan-sync             Read JSONL from stdin, upsert tasks into the database
  plan-export [--json]  Dump the full task DAG (table or JSONL)
  plan-status           Print summary: N open, N active, N done, N blocked, N deleted

Build Phase Commands:
  claim [--lease N]          Atomically claim highest-priority unblocked task
  renew <id> [--lease N]     Extend lease on an active task
  step-done <id> <seq>       Mark a step as done
  done <id> --result '<json>'  Mark task as done, store result
  fail <id> --reason "<text>"  Release task back to open

Shared Commands:
  list [--status S] [--json]   List tasks (default: non-deleted)
  show <id> [--with-deps]      Full detail for one task
  create <id> <title> [opts]   Create a task
  update <id> [opts]           Update fields on a non-done task
  delete <id>                  Soft delete a task
  deps <id>                    Show dependency tree

Dependency Commands:
  block <id> --by <blocker-id>    Add a dependency
  unblock <id> --by <blocker-id>  Remove a dependency

Agent Commands:
  agent register              Register a new agent
  agent list                  Show active agents
  agent deregister <id>       Mark agent as stopped

Environment:
  RALPH_DB_URL   PostgreSQL connection string (required)
EOF
}

# ---------------------------------------------------------------------------
# Subcommand stubs (will be implemented in subsequent tasks)
# ---------------------------------------------------------------------------
cmd_plan_sync()    { echo "plan-sync: not yet implemented" >&2; exit 1; }
cmd_plan_export()  { echo "plan-export: not yet implemented" >&2; exit 1; }
cmd_plan_status()  { echo "plan-status: not yet implemented" >&2; exit 1; }
cmd_claim()        { echo "claim: not yet implemented" >&2; exit 1; }
cmd_renew()        { echo "renew: not yet implemented" >&2; exit 1; }
cmd_step_done()    { echo "step-done: not yet implemented" >&2; exit 1; }
cmd_done()         { echo "done: not yet implemented" >&2; exit 1; }
cmd_fail()         { echo "fail: not yet implemented" >&2; exit 1; }
cmd_list() {
    local status_filter=""
    local json_output=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status) status_filter="$2"; shift 2 ;;
            --json)   json_output=1; shift ;;
            *) echo "Error: unknown flag '$1'" >&2; exit 1 ;;
        esac
    done

    # Build WHERE clause
    local where_clause
    if [[ -n "$status_filter" ]]; then
        # Convert comma-separated statuses to SQL IN clause
        local in_list=""
        IFS=',' read -ra statuses <<< "$status_filter"
        for s in "${statuses[@]}"; do
            s=$(printf '%s' "$s" | xargs)  # trim whitespace
            if [[ -n "$in_list" ]]; then
                in_list+=","
            fi
            in_list+="'${s}'"
        done
        where_clause="WHERE status IN (${in_list})"
    else
        where_clause="WHERE status != 'deleted'"
    fi

    if [[ "$json_output" -eq 1 ]]; then
        # JSONL output with short keys
        psql_cmd -c "
            SELECT json_build_object(
                'id', t.id,
                't', t.title,
                'd', t.description,
                'p', t.priority,
                's', t.status,
                'cat', t.category,
                'spec', t.spec_ref,
                'ref', t.ref,
                'deps', COALESCE((SELECT json_agg(td.blocked_by) FROM task_deps td WHERE td.task_id = t.id), '[]'::json),
                'steps', COALESCE((SELECT json_agg(json_build_object('seq', ts.seq, 'content', ts.content, 'status', ts.status) ORDER BY ts.seq) FROM task_steps ts WHERE ts.task_id = t.id), '[]'::json)
            )
            FROM tasks t
            ${where_clause}
            ORDER BY t.priority ASC, t.created_at ASC;
        "
    else
        # Table output: ID, P, S, CAT, TITLE, AGENT
        local result
        result=$(psql_cmd -c "
            SELECT t.id, t.priority, t.status, COALESCE(t.category, '-'), t.title, COALESCE(t.assignee, '-')
            FROM tasks t
            ${where_clause}
            ORDER BY t.priority ASC, t.created_at ASC;
        ")

        if [[ -z "$result" ]]; then
            return 0
        fi

        # Print header and rows with column alignment
        printf '%-20s %s %-8s %-5s %-35s %s\n' "ID" "P" "S" "CAT" "TITLE" "AGENT"
        while IFS='|' read -r id priority status category title assignee; do
            printf '%-20s %s %-8s %-5s %-35s %s\n' "$id" "$priority" "$status" "$category" "$title" "$assignee"
        done <<< "$result"
    fi
}
cmd_show() {
    local id="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$id" ]]; then
        echo "Error: missing task ID" >&2
        echo "Usage: task show <id> [--with-deps]" >&2
        exit 1
    fi

    local with_deps=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --with-deps) with_deps=1; shift ;;
            *) echo "Error: unknown flag '$1'" >&2; exit 1 ;;
        esac
    done

    # Query the task
    local task_row
    task_row=$(psql_cmd -c "
        SELECT id, title, description, category, priority, status, spec_ref, ref,
               result, assignee, lease_expires_at, retry_count, created_at, updated_at, deleted_at
        FROM tasks WHERE id = '$(printf '%s' "$id" | sed "s/'/''/g")';
    ")

    if [[ -z "$task_row" ]]; then
        echo "Error: task '$id' not found" >&2
        exit 2
    fi

    # Parse task fields from pipe-delimited output
    IFS='|' read -r t_id t_title t_desc t_cat t_pri t_status t_spec t_ref \
        t_result t_assignee t_lease t_retry t_created t_updated t_deleted <<< "$task_row"

    # Print task detail
    printf 'ID:          %s\n' "$t_id"
    printf 'Title:       %s\n' "$t_title"
    printf 'Status:      %s\n' "$t_status"
    printf 'Priority:    %s\n' "$t_pri"
    [[ -n "$t_cat" ]] && printf 'Category:    %s\n' "$t_cat"
    [[ -n "$t_desc" ]] && printf 'Description: %s\n' "$t_desc"
    [[ -n "$t_spec" ]] && printf 'Spec:        %s\n' "$t_spec"
    [[ -n "$t_ref" ]] && printf 'Ref:         %s\n' "$t_ref"
    [[ -n "$t_assignee" ]] && printf 'Assignee:    %s\n' "$t_assignee"
    [[ -n "$t_lease" ]] && printf 'Lease:       %s\n' "$t_lease"
    [[ "$t_retry" != "0" ]] && printf 'Retries:     %s\n' "$t_retry"
    [[ -n "$t_result" ]] && printf 'Result:      %s\n' "$t_result"
    printf 'Created:     %s\n' "$t_created"
    [[ -n "$t_updated" ]] && printf 'Updated:     %s\n' "$t_updated"
    [[ -n "$t_deleted" ]] && printf 'Deleted:     %s\n' "$t_deleted"

    # Query steps
    local steps
    steps=$(psql_cmd -c "
        SELECT seq, status, content FROM task_steps
        WHERE task_id = '$(printf '%s' "$id" | sed "s/'/''/g")'
        ORDER BY seq;
    ")

    if [[ -n "$steps" ]]; then
        printf '\nSteps:\n'
        while IFS='|' read -r s_seq s_status s_content; do
            printf '  %s. [%s] %s\n' "$s_seq" "$s_status" "$s_content"
        done <<< "$steps"
    fi

    # Query dependencies
    local deps
    deps=$(psql_cmd -c "
        SELECT td.blocked_by, t.status
        FROM task_deps td
        JOIN tasks t ON t.id = td.blocked_by
        WHERE td.task_id = '$(printf '%s' "$id" | sed "s/'/''/g")'
        ORDER BY td.blocked_by;
    ")

    if [[ -n "$deps" ]]; then
        printf '\nDependencies:\n'
        while IFS='|' read -r d_id d_status; do
            printf '  %s (%s)\n' "$d_id" "$d_status"
        done <<< "$deps"
    fi

    # With --with-deps: show blocker task results
    if [[ "$with_deps" -eq 1 ]]; then
        local blocker_results
        blocker_results=$(psql_cmd -c "
            SELECT t.id, t.result
            FROM task_deps td
            JOIN tasks t ON t.id = td.blocked_by
            WHERE td.task_id = '$(printf '%s' "$id" | sed "s/'/''/g")'
              AND t.result IS NOT NULL
            ORDER BY t.id;
        ")

        if [[ -n "$blocker_results" ]]; then
            printf '\nBlocker Results:\n'
            while IFS='|' read -r br_id br_result; do
                printf '  %s: %s\n' "$br_id" "$br_result"
            done <<< "$blocker_results"
        fi
    fi
}
cmd_create() {
    local id="${1:-}"
    shift 2>/dev/null || true
    local title="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$id" ]]; then
        echo "Error: missing task ID" >&2
        echo "Usage: task create <id> <title> [-p PRIORITY] [-c CATEGORY] [-d DESCRIPTION] [-s STEPS_JSON] [-r SPEC_REF] [--ref REF] [--deps DEP_IDS]" >&2
        exit 1
    fi

    if [[ -z "$title" ]]; then
        echo "Error: missing task title" >&2
        echo "Usage: task create <id> <title> [-p PRIORITY] [-c CATEGORY] [-d DESCRIPTION] [-s STEPS_JSON] [-r SPEC_REF] [--ref REF] [--deps DEP_IDS]" >&2
        exit 1
    fi

    local priority=2
    local category=""
    local description=""
    local steps_json=""
    local spec_ref=""
    local ref=""
    local deps=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p) priority="$2"; shift 2 ;;
            -c) category="$2"; shift 2 ;;
            -d) description="$2"; shift 2 ;;
            -s) steps_json="$2"; shift 2 ;;
            -r) spec_ref="$2"; shift 2 ;;
            --ref) ref="$2"; shift 2 ;;
            --deps) deps="$2"; shift 2 ;;
            *) echo "Error: unknown flag '$1'" >&2; exit 1 ;;
        esac
    done

    # sql_esc: double single quotes for SQL string literals
    sql_esc() { printf '%s' "$1" | sed "s/'/''/g"; }

    local esc_id esc_title esc_desc esc_category esc_spec_ref esc_ref
    esc_id=$(sql_esc "$id")
    esc_title=$(sql_esc "$title")
    esc_desc=$(sql_esc "$description")
    esc_category=$(sql_esc "$category")
    esc_spec_ref=$(sql_esc "$spec_ref")
    esc_ref=$(sql_esc "$ref")

    # Build INSERT for tasks
    local sql
    sql="BEGIN;
INSERT INTO tasks (id, title, description, category, priority, spec_ref, ref, updated_at)
VALUES ('${esc_id}', '${esc_title}'"
    if [[ -n "$description" ]]; then
        sql+=", '${esc_desc}'"
    else
        sql+=", NULL"
    fi
    if [[ -n "$category" ]]; then
        sql+=", '${esc_category}'"
    else
        sql+=", NULL"
    fi
    sql+=", ${priority}"
    if [[ -n "$spec_ref" ]]; then
        sql+=", '${esc_spec_ref}'"
    else
        sql+=", NULL"
    fi
    if [[ -n "$ref" ]]; then
        sql+=", '${esc_ref}'"
    else
        sql+=", NULL"
    fi
    sql+=", now());"

    # Insert steps from JSON array: [{"content":"step text"}, ...]
    if [[ -n "$steps_json" ]]; then
        local step_count
        step_count=$(printf '%s' "$steps_json" | jq 'length')
        for ((i=0; i<step_count; i++)); do
            local step_content esc_step
            step_content=$(printf '%s' "$steps_json" | jq -r ".[$i].content")
            esc_step=$(sql_esc "$step_content")
            sql+="
INSERT INTO task_steps (task_id, seq, content) VALUES ('${esc_id}', $((i+1)), '${esc_step}');"
        done
    fi

    # Insert dependencies
    if [[ -n "$deps" ]]; then
        IFS=',' read -ra dep_arr <<< "$deps"
        for dep in "${dep_arr[@]}"; do
            dep=$(printf '%s' "$dep" | xargs)  # trim whitespace
            local esc_dep
            esc_dep=$(sql_esc "$dep")
            sql+="
INSERT INTO task_deps (task_id, blocked_by) VALUES ('${esc_id}', '${esc_dep}');"
        done
    fi

    sql+="
COMMIT;"

    printf '%s\n' "$sql" | psql_cmd --set ON_ERROR_STOP=1 > /dev/null
    echo "$id"
}
cmd_update() {
    local id="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$id" ]]; then
        echo "Error: missing task ID" >&2
        echo "Usage: task update <id> [--title T] [--priority N] [--description D] [--steps S] [--status S]" >&2
        exit 1
    fi

    local title="" priority="" description="" steps_json="" status=""
    local has_title=0 has_priority=0 has_description=0 has_steps=0 has_status=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --title)       title="$2"; has_title=1; shift 2 ;;
            --priority)    priority="$2"; has_priority=1; shift 2 ;;
            --description) description="$2"; has_description=1; shift 2 ;;
            --steps)       steps_json="$2"; has_steps=1; shift 2 ;;
            --status)      status="$2"; has_status=1; shift 2 ;;
            *) echo "Error: unknown flag '$1'" >&2; exit 1 ;;
        esac
    done

    # Check that at least one field is provided
    if [[ "$has_title" -eq 0 && "$has_priority" -eq 0 && "$has_description" -eq 0 && "$has_steps" -eq 0 && "$has_status" -eq 0 ]]; then
        echo "Error: no fields to update" >&2
        exit 1
    fi

    # sql_esc: double single quotes for SQL string literals
    sql_esc() { printf '%s' "$1" | sed "s/'/''/g"; }

    local esc_id
    esc_id=$(sql_esc "$id")

    # Check task exists and is not done
    local current_status
    current_status=$(psql_cmd -c "SELECT status FROM tasks WHERE id = '${esc_id}';")

    if [[ -z "$current_status" ]]; then
        echo "Error: task '$id' not found" >&2
        exit 2
    fi

    if [[ "$current_status" == "done" ]]; then
        echo "Error: task '$id' is done and cannot be updated" >&2
        exit 1
    fi

    # Build SET clause dynamically
    local set_parts=()
    if [[ "$has_title" -eq 1 ]]; then
        set_parts+=("title = '$(sql_esc "$title")'")
    fi
    if [[ "$has_priority" -eq 1 ]]; then
        set_parts+=("priority = ${priority}")
    fi
    if [[ "$has_description" -eq 1 ]]; then
        set_parts+=("description = '$(sql_esc "$description")'")
    fi
    if [[ "$has_status" -eq 1 ]]; then
        set_parts+=("status = '$(sql_esc "$status")'")
    fi
    # Always set updated_at
    set_parts+=("updated_at = now()")

    local set_clause
    set_clause=$(IFS=', '; echo "${set_parts[*]}")

    local sql="BEGIN;"
    sql+="
UPDATE tasks SET ${set_clause} WHERE id = '${esc_id}';"

    # If --steps provided, delete existing and insert new
    if [[ "$has_steps" -eq 1 ]]; then
        sql+="
DELETE FROM task_steps WHERE task_id = '${esc_id}';"
        if [[ -n "$steps_json" ]]; then
            local step_count
            step_count=$(printf '%s' "$steps_json" | jq 'length')
            for ((i=0; i<step_count; i++)); do
                local step_content esc_step
                step_content=$(printf '%s' "$steps_json" | jq -r ".[$i].content")
                esc_step=$(sql_esc "$step_content")
                sql+="
INSERT INTO task_steps (task_id, seq, content) VALUES ('${esc_id}', $((i+1)), '${esc_step}');"
            done
        fi
    fi

    sql+="
COMMIT;"

    printf '%s\n' "$sql" | psql_cmd --set ON_ERROR_STOP=1 > /dev/null
    echo "updated $id"
}
cmd_delete()       { echo "delete: not yet implemented" >&2; exit 1; }
cmd_deps()         { echo "deps: not yet implemented" >&2; exit 1; }
cmd_block()        { echo "block: not yet implemented" >&2; exit 1; }
cmd_unblock()      { echo "unblock: not yet implemented" >&2; exit 1; }

cmd_agent() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true
    case "$subcmd" in
        register)   echo "agent register: not yet implemented" >&2; exit 1 ;;
        list)       echo "agent list: not yet implemented" >&2; exit 1 ;;
        deregister) echo "agent deregister: not yet implemented" >&2; exit 1 ;;
        "")
            echo "Error: missing agent subcommand" >&2
            echo "Usage: task agent <register|list|deregister>" >&2
            exit 1
            ;;
        *)
            echo "Error: unknown agent subcommand '$subcmd'" >&2
            exit 1
            ;;
    esac
}

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------
main() {
    local cmd="${1:-}"
    shift 2>/dev/null || true

    case "$cmd" in
        --help|-h)
            usage
            exit 0
            ;;
        plan-sync)    db_check; ensure_schema; cmd_plan_sync "$@" ;;
        plan-export)  db_check; ensure_schema; cmd_plan_export "$@" ;;
        plan-status)  db_check; ensure_schema; cmd_plan_status "$@" ;;
        claim)        db_check; ensure_schema; cmd_claim "$@" ;;
        renew)        db_check; ensure_schema; cmd_renew "$@" ;;
        step-done)    db_check; ensure_schema; cmd_step_done "$@" ;;
        done)         db_check; ensure_schema; cmd_done "$@" ;;
        fail)         db_check; ensure_schema; cmd_fail "$@" ;;
        list)         db_check; ensure_schema; cmd_list "$@" ;;
        show)         db_check; ensure_schema; cmd_show "$@" ;;
        create)       db_check; ensure_schema; cmd_create "$@" ;;
        update)       db_check; ensure_schema; cmd_update "$@" ;;
        delete)       db_check; ensure_schema; cmd_delete "$@" ;;
        deps)         db_check; ensure_schema; cmd_deps "$@" ;;
        block)        db_check; ensure_schema; cmd_block "$@" ;;
        unblock)      db_check; ensure_schema; cmd_unblock "$@" ;;
        agent)        db_check; ensure_schema; cmd_agent "$@" ;;
        "")
            echo "Error: missing command" >&2
            echo "" >&2
            usage >&2
            exit 1
            ;;
        *)
            echo "Error: unknown command '$cmd'" >&2
            exit 1
            ;;
    esac
}

main "$@"
